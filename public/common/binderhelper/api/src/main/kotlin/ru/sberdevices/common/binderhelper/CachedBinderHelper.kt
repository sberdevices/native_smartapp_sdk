package ru.sberdevices.common.binderhelper

import android.os.IInterface
import java.lang.IllegalStateException

/**
 * Интерфейс для подключения к aidl сервисам. Имплементацию нужно получать в [BinderHelperFactory2].
 * Является оберткой над [BinderHelper] с поддержкой кеширования соединения
 *
 * Кеширует соединение с сервисом и сам управляет им. Не требует явного соединения с сервисом [connect].
 * Позволяет использовать одно физическое соединение для независимого обращения к сервису из разных потоков.
 *
 * Для выполнения aidl метода достаточно просто вызывать метод [execute].
 * Внутри автоматически выполнится [connect], если соединения с сервисом еще не было.
 * Если нет других процессов, использующих соединение с сервисом, то по завершению метода [execute] автоматически
 * выполнится [disconnect] с заданной задержкой
 *
 * В случае явного вызова [connect], соединение с сервисом будет поддерживаться до явного вызова [disconnect]
 * Так как внутри используется счетчик соединений, то каждый явный вызов [connect] должен сопровождаться
 * явным вызовом [disconnect]
 *
 * В случае рассинхронизации вызовов [connect], [disconnect] может вызвать исключение [IllegalStateException],
 * если внутренний счетчик соединений станет меньше 0
 *
 */
interface CachedBinderHelper<BinderInterface : IInterface> : BinderHelper<BinderInterface> {

    /**
     * Есть активное соединение с сервисом
     */
    val hasConnection: Boolean

    /**
     * Количество виртуальных соединений
     */
    val connectionCount: Int

    /**
     * Устанавливает соединение с сервисом и поддерживает его до явного вызова [disconnect].
     * Если физическое соединение с сервисом уже существует, то просто увеличивает счетчик соединений [connectionCount]
     * Каждый явный вызов [connect] требует явного вызова [disconnect]
     */
    override fun connect(): Boolean

    /**
     * Уменьшает внутренний счетчик соединений [connectionCount].
     * Физическое рассоединение с сервисом произойдет, когда внутренний счетчик станет равен 0
     *
     * В целях оптимизации, физическое рассоединение всегда происходит с заданной задержкой.
     * Это позволяет переиспользовать соединения с сервсиом в случае частых обращений к сервису
     *
     * В случае рассинхронизации вызовов [connect], [disconnect] может вызвать исключение [IllegalStateException],
     * если внутренний счетчик соединений [connectionCount] станет меньше 0
     */
    @Throws(IllegalStateException::class)
    override fun disconnect()

    /**
     * Вызывает aidl метод сервиса и не требует явного соединения с сервисом.
     *
     * Внутри автоматически выполнится [connect], если соединения с сервисом еще не было.
     * Если нет других процессов, использующих соединение с сервисом, то по завершению метода [execute] автоматически
     * выполнится [disconnect] с заданной задержкой
     */
    override suspend fun <Result> execute(method: (binder: BinderInterface) -> Result?): Result?
}
